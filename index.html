<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebBench - CPU Benchmark</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=JetBrains+Mono:wght@400;700&display=swap');
        
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a1a1a;
            color: #e5e5e5;
        }
        
        .mono {
            font-family: 'JetBrains Mono', monospace;
        }

        .canvas-container {
            position: relative;
            width: 100%;
            padding-bottom: 56.25%; /* 16:9 Aspect Ratio */
            background-color: #000;
            border: 1px solid #333;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.5);
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
        }

        .btn-start {
            background: linear-gradient(135deg, #f97316 0%, #ea580c 100%);
            transition: all 0.2s;
        }
        .btn-start:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(234, 88, 12, 0.4);
        }
        .btn-start:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            filter: grayscale(0.8);
        }

        .stat-card {
            background-color: #262626;
            border-left: 4px solid #f97316;
        }

        .grid-bg {
            background-image: 
                linear-gradient(rgba(255, 255, 255, 0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.05) 1px, transparent 1px);
            background-size: 20px 20px;
        }

        /* Loading shimmer for status */
        @keyframes shimmer {
            0% { opacity: 0.5; }
            50% { opacity: 1; }
            100% { opacity: 0.5; }
        }
        .rendering-pulse {
            animation: shimmer 1.5s infinite;
        }
    </style>
</head>
<body class="min-h-screen grid-bg flex flex-col items-center justify-center p-4">

    <!-- Header -->
    <header class="w-full max-w-5xl mb-6 flex justify-between items-end">
        <div>
            <h1 class="text-3xl font-bold text-white tracking-tight">Web<span class="text-orange-500">Bench</span></h1>
            <p class="text-gray-400 text-sm mt-1">High-Load JavaScript Raytracing Benchmark</p>
        </div>
        <div class="text-right">
            <div id="system-info" class="text-sm text-gray-300 mono">検知中...</div>
        </div>
    </header>

    <!-- Main Content -->
    <main class="w-full max-w-5xl grid grid-cols-1 lg:grid-cols-4 gap-6">
        
        <!-- Left Sidebar (Controls & Stats) -->
        <aside class="lg:col-span-1 space-y-4 order-2 lg:order-1">
            
            <!-- Controls -->
            <div class="bg-neutral-800 p-4 rounded-lg border border-neutral-700 shadow-lg">
                <button id="start-btn" class="btn-start w-full py-3 px-4 rounded font-bold text-white text-lg shadow-md mb-3 flex items-center justify-center gap-2">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z" />
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                    </svg>
                    Start
                </button>
                <div class="text-xs text-gray-500 text-center">
                    高負荷テストです。<br>CPU使用率が100%になります。
                </div>
            </div>

            <!-- Live Status -->
            <div class="stat-card p-4 rounded-r-lg shadow-lg">
                <div class="text-gray-400 text-xs uppercase tracking-wider mb-1">Status</div>
                <div id="status-text" class="text-white font-medium">Ready</div>
                
                <div class="w-full bg-gray-700 h-1.5 mt-3 rounded-full overflow-hidden">
                    <div id="progress-bar" class="h-full bg-orange-500 w-0 transition-all duration-300"></div>
                </div>
                <div id="progress-text" class="text-right text-xs text-orange-400 mt-1 mono">0%</div>
            </div>

            <!-- Score Box -->
            <div class="bg-neutral-800 p-4 rounded-lg border border-neutral-700 shadow-lg relative overflow-hidden group">
                <div class="text-gray-400 text-xs uppercase tracking-wider mb-2">Score</div>
                <div class="flex items-baseline gap-1">
                    <span id="score-display" class="text-4xl font-bold text-orange-500 mono">--</span>
                    <span class="text-sm text-gray-500 font-bold">pts</span>
                </div>
                <div id="time-display" class="text-xs text-gray-500 mt-2 mono">Time: --:--</div>
            </div>

            <!-- Tech Specs -->
            <div class="bg-neutral-900 p-4 rounded-lg border border-neutral-800 text-xs text-gray-400 space-y-2 font-mono">
                <div class="flex justify-between">
                    <span>Threads:</span>
                    <span id="thread-count" class="text-gray-200">--</span>
                </div>
                <div class="flex justify-between">
                    <span>Resolution:</span>
                    <span class="text-gray-200">1280x720</span>
                </div>
                <div class="flex justify-between">
                    <span>Samples/Px:</span>
                    <span class="text-gray-200 text-orange-400">64 (High)</span>
                </div>
            </div>
        </aside>

        <!-- Right Content (Viewport) -->
        <div class="lg:col-span-3 order-1 lg:order-2">
            <div class="canvas-container rounded-lg overflow-hidden relative">
                <canvas id="render-canvas" width="1280" height="720"></canvas>
                
                <!-- Overlay for "Finished" -->
                <div id="finish-overlay" class="absolute inset-0 bg-black bg-opacity-60 flex items-center justify-center opacity-0 pointer-events-none transition-opacity duration-500">
                    <div class="text-center transform scale-90 transition-transform duration-500" id="finish-content">
                        <h2 class="text-4xl font-bold text-white mb-2">Render Complete</h2>
                        <p class="text-orange-400 text-xl font-mono" id="final-score-overlay">0 pts</p>
                    </div>
                </div>
            </div>
        </div>

    </main>

    <footer class="mt-8 text-gray-600 text-xs text-center">
        <p>WebRayBench uses CPU-based ray tracing via Web Workers.</p>
        <p class="mt-1 opacity-50">Caution: High CPU usage expected.</p>
    </footer>

    <!-- Worker Script -->
    <script id="worker-code" type="javascript/worker">
        // --- Vector Math Class ---
        class Vec3 {
            constructor(x, y, z) { this.x = x; this.y = y; this.z = z; }
            add(v) { return new Vec3(this.x + v.x, this.y + v.y, this.z + v.z); }
            sub(v) { return new Vec3(this.x - v.x, this.y - v.y, this.z - v.z); }
            mul(s) { return new Vec3(this.x * s, this.y * s, this.z * s); }
            dot(v) { return this.x * v.x + this.y * v.y + this.z * v.z; }
            cross(v) { return new Vec3(this.y * v.z - this.z * v.y, this.z * v.x - this.x * v.z, this.x * v.y - this.y * v.x); }
            normalize() { 
                let mag = Math.sqrt(this.x*this.x + this.y*this.y + this.z*this.z); 
                return mag === 0 ? new Vec3(0,0,0) : new Vec3(this.x/mag, this.y/mag, this.z/mag); 
            }
        }

        // --- Random Generator (Simple LCG for deterministic scene in workers) ---
        // We actually want deterministic scene across workers so everyone renders same world.
        let seed = 123456789;
        function random() {
            seed = (1103515245 * seed + 12345) % 2147483648;
            return seed / 2147483648;
        }
        function randomRange(min, max) { return min + (max - min) * random(); }

        // --- Scene Setup ---
        let spheres = [];
        
        function initScene() {
            if (spheres.length > 0) return;

            // Ground
            spheres.push({ center: new Vec3(0, -1000, 0), radius: 1000, color: new Vec3(0.5, 0.5, 0.5), type: 'matte' });

            // Big spheres
            spheres.push({ center: new Vec3(0, 1, 0), radius: 1.0, color: new Vec3(1.0, 0.2, 0.2), type: 'matte' }); // Red
            spheres.push({ center: new Vec3(-4, 1, 0), radius: 1.0, color: new Vec3(0.4, 0.8, 0.4), type: 'matte' }); // Green
            spheres.push({ center: new Vec3(4, 1, 0), radius: 1.0, color: new Vec3(0.7, 0.6, 0.5), type: 'metal' }); // Metal

            // Generate many random small spheres to increase intersection cost
            // This is the "Extreme" part - checking intersection against many objects per ray
            for (let a = -11; a < 11; a++) {
                for (let b = -11; b < 11; b++) {
                    const chooseMat = random();
                    const center = new Vec3(a + 0.9 * random(), 0.2, b + 0.9 * random());
                    
                    if (center.sub(new Vec3(4, 0.2, 0)).dot(center.sub(new Vec3(4, 0.2, 0))) > 0.9) {
                        if (chooseMat < 0.8) {
                            // diffuse
                            const col = new Vec3(random()*random(), random()*random(), random()*random());
                            spheres.push({ center: center, radius: 0.2, color: col, type: 'matte' });
                        } else {
                            // metal
                            const col = new Vec3(0.5 * (1 + random()), 0.5 * (1 + random()), 0.5 * (1 + random()));
                            spheres.push({ center: center, radius: 0.2, color: col, type: 'metal' });
                        }
                    }
                }
            }
        }

        const lights = [
            { pos: new Vec3(-10, 20, 10), intensity: 1.2 },
            { pos: new Vec3(10, 20, -10), intensity: 0.8 },
        ];

        function intersectSphere(origin, dir, sphere) {
            const L = sphere.center.sub(origin);
            const tca = L.dot(dir);
            if (tca < 0) return { hit: false };
            const d2 = L.dot(L) - tca * tca;
            if (d2 > sphere.radius * sphere.radius) return { hit: false };
            const thc = Math.sqrt(sphere.radius * sphere.radius - d2);
            return { hit: true, dist: tca - thc };
        }

        function trace(origin, dir, depth) {
            let nearestDist = Infinity;
            let hitObj = null;

            // Brute force intersection check against ALL spheres
            // With ~100 spheres, this becomes expensive per ray
            for (let s of spheres) {
                const res = intersectSphere(origin, dir, s);
                if (res.hit && res.dist < nearestDist && res.dist > 0.001) {
                    nearestDist = res.dist;
                    hitObj = s;
                }
            }

            if (!hitObj) {
                const unitDir = dir.normalize();
                const t = 0.5 * (unitDir.y + 1.0);
                return new Vec3(1.0, 1.0, 1.0).mul(1.0 - t).add(new Vec3(0.5, 0.7, 1.0).mul(t)); // Sky
            }

            const hitPoint = origin.add(dir.mul(nearestDist));
            const normal = hitPoint.sub(hitObj.center).normalize();
            
            // Limit recursion depth to keep it finite but heavy
            if (depth < 8) { // Increased depth limit for more reflections
                if (hitObj.type === 'metal') {
                    const reflectDir = dir.sub(normal.mul(2 * dir.dot(normal))).normalize();
                    // Add some fuzziness to metal
                    const fuzz = 0.1;
                    const fuzzedDir = reflectDir.add(new Vec3(random()-0.5, random()-0.5, random()-0.5).mul(fuzz)).normalize();
                    if (fuzzedDir.dot(normal) > 0) {
                        return trace(hitPoint.add(normal.mul(0.001)), fuzzedDir, depth + 1).mul(0.8);
                    }
                }
            }

            // Matte (Lambertian approx with simple lighting)
            let color = new Vec3(0, 0, 0);
            for (let light of lights) {
                const lightDir = light.pos.sub(hitPoint).normalize();
                
                // Shadow Check (Expensive!)
                let inShadow = false;
                for (let s of spheres) {
                    if (s === hitObj) continue;
                    // Simple optimization: only check shadows if sphere is somewhat in the direction of light
                    const res = intersectSphere(hitPoint.add(normal.mul(0.001)), lightDir, s);
                    if (res.hit) {
                        const distToLight = light.pos.sub(hitPoint).dot(lightDir);
                        if (res.dist < distToLight) {
                            inShadow = true;
                            break;
                        }
                    }
                }

                if (!inShadow) {
                    const diff = Math.max(0, normal.dot(lightDir));
                    color = color.add(hitObj.color.mul(diff * light.intensity));
                }
            }

            return color.add(hitObj.color.mul(0.1)); // Ambient
        }

        self.onmessage = function(e) {
            initScene(); // Ensure scene is generated
            const { id, startX, startY, width, height, canvasWidth, canvasHeight } = e.data;
            
            const data = new Uint8ClampedArray(width * height * 4);
            
            // Camera
            const lookFrom = new Vec3(13, 2, 3);
            const lookAt = new Vec3(0, 0, 0);
            const vup = new Vec3(0, 1, 0);
            const distToFocus = 10.0;
            const aperture = 0.1;

            const w = lookFrom.sub(lookAt).normalize();
            const u = vup.cross(w).normalize();
            const v = w.cross(u);

            const vfov = 20;
            const aspect = canvasWidth / canvasHeight;
            const theta = vfov * Math.PI / 180;
            const halfHeight = Math.tan(theta/2);
            const halfWidth = aspect * halfHeight;

            const origin = lookFrom;
            const lowerLeftCorner = origin
                .sub(u.mul(halfWidth * distToFocus))
                .sub(v.mul(halfHeight * distToFocus))
                .sub(w.mul(distToFocus));
            const horizontal = u.mul(2 * halfWidth * distToFocus);
            const vertical = v.mul(2 * halfHeight * distToFocus);

            // High load settings
            const samplesPerPixel = 64; // HEAVY LOAD

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const globalX = startX + x;
                    const globalY = (canvasHeight - 1) - (startY + y); 

                    let pixelColor = new Vec3(0,0,0);

                    for(let s = 0; s < samplesPerPixel; s++) {
                        const s_u = (globalX + random()) / (canvasWidth - 1);
                        const s_v = (globalY + random()) / (canvasHeight - 1);
                        
                        const rayDir = lowerLeftCorner.add(horizontal.mul(s_u)).add(vertical.mul(s_v)).sub(origin).normalize();
                        pixelColor = pixelColor.add(trace(origin, rayDir, 0));
                    }

                    pixelColor = pixelColor.mul(1.0 / samplesPerPixel);
                    pixelColor = new Vec3(Math.sqrt(pixelColor.x), Math.sqrt(pixelColor.y), Math.sqrt(pixelColor.z)); // Gamma

                    const index = (y * width + x) * 4;
                    data[index] = Math.min(255, Math.floor(pixelColor.x * 255.99));
                    data[index + 1] = Math.min(255, Math.floor(pixelColor.y * 255.99));
                    data[index + 2] = Math.min(255, Math.floor(pixelColor.z * 255.99));
                    data[index + 3] = 255;
                }
            }

            self.postMessage({
                id,
                startX,
                startY,
                width,
                height,
                buffer: data.buffer
            }, [data.buffer]);
        };
    </script>

    <script>
        const canvas = document.getElementById('render-canvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        const startBtn = document.getElementById('start-btn');
        const statusText = document.getElementById('status-text');
        const progressBar = document.getElementById('progress-bar');
        const progressNum = document.getElementById('progress-text');
        const scoreDisplay = document.getElementById('score-display');
        const timeDisplay = document.getElementById('time-display');
        const threadInfo = document.getElementById('thread-count');
        const systemInfo = document.getElementById('system-info');
        const finishOverlay = document.getElementById('finish-overlay');
        const finalScoreOverlay = document.getElementById('final-score-overlay');

        // Settings
        const TILE_SIZE = 32; // Smaller tiles for more frequent updates under high load
        const CANVAS_WIDTH = 1280;
        const CANVAS_HEIGHT = 720;
        const SAMPLES_PER_PIXEL = 64; // Must match worker
        
        const logicalProcessors = navigator.hardwareConcurrency || 4;
        threadInfo.innerText = `${logicalProcessors} Logical Cores`;
        systemInfo.innerText = `System: ${logicalProcessors} Threads`;

        let startTime = 0;
        let totalTiles = 0;
        let completedTiles = 0;
        let workers = [];
        let tilesQueue = [];
        let activeWorkers = 0;
        let isRunning = false;

        const workerBlob = new Blob([document.getElementById('worker-code').textContent], { type: "text/javascript" });
        const workerUrl = URL.createObjectURL(workerBlob);

        function createTiles() {
            const tiles = [];
            for (let y = 0; y < CANVAS_HEIGHT; y += TILE_SIZE) {
                for (let x = 0; x < CANVAS_WIDTH; x += TILE_SIZE) {
                    const w = Math.min(TILE_SIZE, CANVAS_WIDTH - x);
                    const h = Math.min(TILE_SIZE, CANVAS_HEIGHT - y);
                    tiles.push({ x, y, w, h });
                }
            }
            // Shuffle for cool visual
            for (let i = tiles.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [tiles[i], tiles[j]] = [tiles[j], tiles[i]];
            }
            return tiles;
        }

        function drawTile(data) {
            const imageData = new ImageData(new Uint8ClampedArray(data.buffer), data.width, data.height);
            ctx.putImageData(imageData, data.startX, data.startY);
            ctx.strokeStyle = '#f97316';
            ctx.lineWidth = 1;
            ctx.strokeRect(data.startX, data.startY, data.width, data.height);
        }

        function updateProgress() {
            completedTiles++;
            const percent = ((completedTiles / totalTiles) * 100).toFixed(1);
            progressBar.style.width = `${percent}%`;
            progressNum.innerText = `${percent}%`;
            
            const now = performance.now();
            const elapsed = ((now - startTime) / 1000).toFixed(1);
            timeDisplay.innerText = `Time: ${elapsed}s`;
        }

        function onTileComplete(workerIndex) {
            if (tilesQueue.length > 0) {
                const tile = tilesQueue.pop();
                workers[workerIndex].postMessage({
                    id: workerIndex,
                    startX: tile.x,
                    startY: tile.y,
                    width: tile.w,
                    height: tile.h,
                    canvasWidth: CANVAS_WIDTH,
                    canvasHeight: CANVAS_HEIGHT
                });
            } else {
                activeWorkers--;
                if (activeWorkers === 0) {
                    finishBenchmark();
                }
            }
        }

        function startBenchmark() {
            if (isRunning) return;
            isRunning = true;
            
            startBtn.disabled = true;
            startBtn.innerHTML = 'Rendering...';
            statusText.innerText = "Processing (High Load)";
            statusText.className = "text-orange-500 font-bold rendering-pulse";
            scoreDisplay.innerText = "--";
            finishOverlay.classList.remove('opacity-100', 'pointer-events-auto');
            finishOverlay.classList.add('opacity-0', 'pointer-events-none');
            
            ctx.fillStyle = "#000";
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            tilesQueue = createTiles();
            totalTiles = tilesQueue.length;
            completedTiles = 0;

            const threadsToUse = Math.min(logicalProcessors, 32); 
            
            if (workers.length === 0) {
                for (let i = 0; i < threadsToUse; i++) {
                    const w = new Worker(workerUrl);
                    w.onmessage = (e) => {
                        drawTile(e.data);
                        updateProgress();
                        onTileComplete(i);
                    };
                    workers.push(w);
                }
            }

            startTime = performance.now();
            activeWorkers = workers.length;

            for (let i = 0; i < workers.length; i++) {
                onTileComplete(i);
            }
        }

        function finishBenchmark() {
            const endTime = performance.now();
            const durationSeconds = (endTime - startTime) / 1000;
            isRunning = false;

            // Revised Score Calculation for "Extreme" workload
            // Total Primary Rays = 1280 * 720 * 64 = 58,982,400
            // Scene complexity factor (approximate spheres checks per ray) ~ 50-100
            // We want a score that feels good. e.g. 5000-10000 range for good CPUs.
            
            const totalPixels = CANVAS_WIDTH * CANVAS_HEIGHT;
            const rays = totalPixels * SAMPLES_PER_PIXEL;
            
            // Adjust divisor to calibrate score to a "Cinebench-like" number
            // 60 million rays / 10 seconds = 6 million rays/sec.
            // Let's say 1000 pts = decent speed.
            const score = Math.floor((rays / durationSeconds) / 2000); 

            startBtn.disabled = false;
            startBtn.innerHTML = 'Start Benchmark';
            statusText.innerText = "Finished";
            statusText.className = "text-green-500 font-bold";
            scoreDisplay.innerText = score;
            finalScoreOverlay.innerText = `${score} pts`;
            
            finishOverlay.classList.remove('opacity-0', 'pointer-events-none');
            finishOverlay.classList.add('opacity-100', 'pointer-events-auto');
            document.getElementById('finish-content').classList.remove('scale-90');
            document.getElementById('finish-content').classList.add('scale-100');
        }

        startBtn.addEventListener('click', startBenchmark);

        ctx.fillStyle = "#0a0a0a";
        ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        ctx.font = "20px JetBrains Mono";
        ctx.fillStyle = "#333";
        ctx.textAlign = "center";
        ctx.fillText("Ready for Heavy Load", CANVAS_WIDTH/2, CANVAS_HEIGHT/2);
    </script>
</body>
</html>
