<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL ベンチマーク</title>
    <!-- Tailwind CSSを読み込みます -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- フォントとしてInterを使用します -->
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        body {
            font-family: 'Inter', 'Noto Sans JP', sans-serif;
            /* キャンバスがクリックイベントを奪うのを防ぎ、下のテキストを選択できるようにします */
            overflow: hidden; 
        }
        #webgl-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        /* [改善点④] Canvasのレイアウトを修正：position: fixed; inset: 0; でiPad等のズレを防止 */
        #canvas-container {
            position: fixed;
            inset: 0;
        }
        /* UI要素がキャンバスより手前に来るようにします */
        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* UI要素以外はクリックを透過 */
        }
        .ui-content {
            pointer-events: auto; /* UI要素はクリック可能に */
        }
    </style>
</head>
<body class="bg-gray-900 text-white">

    <!-- 3D描画用のキャンバス -->
    <div id="canvas-container">
        <canvas id="webgl-canvas"></canvas>
    </div>

    <!-- UIオーバーレイ -->
    <div class="ui-overlay flex flex-col items-center justify-center min-h-screen p-4 sm:p-8">
        <div class="ui-content bg-gray-900 bg-opacity-80 backdrop-blur-sm p-6 sm:p-8 rounded-2xl shadow-xl text-center max-w-xl w-full">
            
            <h1 class="text-3xl sm:text-4xl font-bold mb-4 text-blue-300">WebGL ベンチマーク</h1>
            <p class="text-sm sm:text-lg text-gray-300 mb-6">
                GPUとCPUの負荷を同時にかけ、設定された秒数で性能を測定します。
            </p>

            <!-- スコア表示エリア -->
            <!-- [改善点⑤] Max FPSとMin FPSの表示を追加し、4分割のグリッドにする -->
            <div class="grid grid-cols-2 md:grid-cols-4 gap-2 mb-6">
                <div class="p-2 sm:p-3 rounded-lg bg-gray-800">
                    <div class="text-xs uppercase text-gray-400">現在のFPS</div>
                    <div id="current-fps" class="text-2xl sm:text-3xl font-bold text-white">-</div>
                </div>
                <div class="p-2 sm:p-3 rounded-lg bg-gray-800">
                    <div class="text-xs uppercase text-gray-400">平均スコア</div>
                    <div id="average-score" class="text-2xl sm:text-3xl font-bold text-green-400">-</div>
                </div>
                 <div class="p-2 sm:p-3 rounded-lg bg-gray-800">
                    <div class="text-xs uppercase text-gray-400">Max FPS</div>
                    <div id="max-fps" class="text-2xl sm:text-3xl font-bold text-yellow-400">-</div>
                </div>
                <div class="p-2 sm:p-3 rounded-lg bg-gray-800">
                    <div class="text-xs uppercase text-gray-400">Min FPS</div>
                    <div id="min-fps" class="text-2xl sm:text-3xl font-bold text-red-400">-</div>
                </div>
            </div>
            
            <!-- ランク表示エリアを独立させる -->
            <div class="p-4 sm:p-5 rounded-lg bg-gray-800 mb-6">
                <div class="text-sm uppercase text-gray-400">最終ランク</div>
                <div id="rank-display" class="text-4xl sm:text-5xl font-extrabold text-gray-500">-</div>
            </div>

            <!-- GPU負荷設定スライダー -->
            <div class="mb-4">
                <label for="loadSliderGpu" class="block text-sm uppercase text-gray-400 mb-2 text-left">GPU負荷 (描画オブジェクト数)</label>
                <div class="flex items-center space-x-4">
                    <input id="loadSliderGpu" type="range" min="0.1" max="10.0" value="1.0" step="0.1" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer disabled:opacity-50">
                    <span id="loadValueGpu" class="text-lg font-bold text-blue-300 w-16 text-right">1.0 x</span>
                </div>
                <div id="loadDescriptionGpu" class="text-xs text-gray-500 mt-2 text-left">
                    (負荷 1.0 = 5000 オブジェクト, 負荷 10.0 = 50000 オブジェクト)
                </div>
            </div>

            <!-- CPU負荷設定スライダー -->
            <div class="mb-6">
                <label for="loadSliderCpu" class="block text-sm uppercase text-gray-400 mb-2 text-left">CPU負荷 (JSONエンコード/デコード)</label>
                <div class="flex items-center space-x-4">
                    <input id="loadSliderCpu" type="range" min="0.1" max="10.0" value="1.0" step="0.1" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer disabled:opacity-50">
                    <span id="loadValueCpu" class="text-lg font-bold text-blue-300 w-16 text-right">1.0 x</span>
                </div>
                <div id="loadDescriptionCpu" class="text-xs text-gray-500 mt-2 text-left">
                    (負荷 1.0 = 標準の計算量, 負荷 10.0 = 最大計算量)
                </div>
            </div>

            <!-- テスト時間設定要素 -->
            <div class="mb-6">
                <label for="testDuration" class="block text-sm uppercase text-gray-400 mb-2 text-left">テスト時間 (秒)</label>
                <div class="flex items-center space-x-4">
                    <input id="testDuration" type="number" min="5" max="60" value="10" step="5" class="w-24 text-center bg-gray-700 text-white p-2 rounded-lg focus:ring-blue-500 focus:border-blue-500 disabled:opacity-50">
                    <span class="text-lg font-bold text-gray-400 w-16 text-left">秒</span>
                </div>
                <div class="text-xs text-gray-500 mt-2 text-left">
                    (5秒から60秒まで設定可能)
                </div>
            </div>

            <!-- ステータス表示 -->
            <div id="status" class="text-lg text-gray-400 h-8 mb-6">
                ボタンを押して開始してください
            </div>

            <!-- 開始ボタン -->
            <button id="startButton" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-4 px-8 rounded-lg text-xl transition-all duration-300 shadow-lg focus:outline-none focus:ring-4 focus:ring-blue-500 focus:ring-opacity-50 disabled:opacity-50 disabled:cursor-not-allowed">
                ベンチマーク開始
            </button>
        </div>
    </div>

    <!-- three.jsライブラリを読み込みます -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.module.min.js"
            }
        }
    </script>

    <!-- メインのスクリプト -->
    <script type="module">
        import * as THREE from 'three';

        // --- DOM要素の取得 ---
        const canvas = document.getElementById('webgl-canvas');
        const canvasContainer = document.getElementById('canvas-container');
        const startButton = document.getElementById('startButton');
        const currentFpsEl = document.getElementById('current-fps');
        const scoreEl = document.getElementById('average-score');
        const statusEl = document.getElementById('status');
        const loadSliderGpu = document.getElementById('loadSliderGpu');
        const loadValueGpuEl = document.getElementById('loadValueGpu');
        const loadDescriptionGpuEl = document.getElementById('loadDescriptionGpu');
        const loadSliderCpu = document.getElementById('loadSliderCpu');
        const loadValueCpuEl = document.getElementById('loadValueCpu');
        const loadDescriptionCpuEl = document.getElementById('loadDescriptionCpu');
        const rankEl = document.getElementById('rank-display');
        const maxFpsEl = document.getElementById('max-fps'); 
        const minFpsEl = document.getElementById('min-fps'); 
        const testDurationEl = document.getElementById('testDuration'); 


        // --- ベンチマーク設定 ---
        const BASE_OBJECT_COUNT = 5000; // 描画するオブジェクトの数 (負荷 1.0 の時)
        let TEST_DURATION = 10; // テスト時間 (秒)

        // [改善案1] マテリアル共有化のための配列と定数
        const NUM_SHARED_MATERIALS = 10; // 共有するマテリアルの種類
        let sharedMaterials = []; 

        // --- 3Dシーンのセットアップ ---
        let scene, camera, renderer, group;
        let geometry; // ジオメトリは共有する
        
        // --- 状態管理 ---
        let isRunning = false;
        let currentLoadFactorGpu = 1.0;
        let currentLoadFactorCpu = 1.0;
        let startTime = 0;
        let lastTime = 0;
        let totalFrames = 0;
        let currentFPS = 0;
        let averageFPS = 0;
        let minFPS = Infinity; 
        let maxFPS = 0;        
        
        // [改善点②] FPSの移動平均用履歴
        const fpsHistory = [];
        const FPS_HISTORY_SIZE = 20;

        // [改善点②] FPSを安定化させるための移動平均計算関数
        function calcSmoothedFPS(delta) {
            const fps = 1 / delta;
            
            // 履歴に追加し、サイズを超えたら最古のものを削除
            fpsHistory.push(fps);
            if (fpsHistory.length > FPS_HISTORY_SIZE) {
                fpsHistory.shift();
            }
            
            // 平均値を計算
            if (fpsHistory.length === 0) return 0;
            const sum = fpsHistory.reduce((a, b) => a + b, 0);
            return sum / fpsHistory.length;
        }

        // 初期化関数
        function init() {
            // シーン
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111827); // 背景色をTailwindのgray-900に合わせる

            // カメラ
            camera = new THREE.PerspectiveCamera(75, canvasContainer.clientWidth / canvasContainer.clientHeight, 0.1, 1000);
            camera.position.z = 80;

            // レンダラー
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Retina対応

            // ライト
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            const pointLight = new THREE.PointLight(0xffffff, 1);
            pointLight.position.set(100, 100, 100);
            scene.add(pointLight);

            // オブジェクトのジオメトリ（1つ作成して共有）
            geometry = new THREE.BoxGeometry(1, 1, 1);
            
            // [改善案1] 共有マテリアルを初期化
            for (let i = 0; i < NUM_SHARED_MATERIALS; i++) {
                sharedMaterials.push(new THREE.MeshStandardMaterial({
                    color: Math.random() * 0xffffff,
                    roughness: 0.7,
                    metalness: 0.3
                }));
            }

            // オブジェクトを格納するグループ
            group = new THREE.Group();
            scene.add(group);

            // --- イベントリスナー ---
            startButton.addEventListener('click', startBenchmark);
            window.addEventListener('resize', onWindowResize);
            
            // GPUスライダー
            loadSliderGpu.addEventListener('input', (e) => {
                loadValueGpuEl.textContent = `${parseFloat(e.target.value).toFixed(1)} x`;
            });
            // CPUスライダー
            loadSliderCpu.addEventListener('input', (e) => {
                loadValueCpuEl.textContent = `${parseFloat(e.target.value).toFixed(1)} x`;
            });
            
            // 初期表示をクリア
            maxFpsEl.textContent = '-';
            minFpsEl.textContent = '-';

            // 初期設定値を取得
            TEST_DURATION = parseInt(testDurationEl.value);

            // アニメーションループ開始
            animate();
        }

        // CPU負荷用のダミーデータ（少し大きめ）
        const cpuLoadData = {
            id: 12345,
            timestamp: Date.now(),
            text: "Lorem ipsum dolor sit amet, consectetur adipiscing elit. ".repeat(100),
            nested: { a: 1, b: "string", c: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], d: true },
            array: Array(50).fill(null).map((_, i) => ({ index: i, value: Math.random() }))
        };

        // [改善点③] CPU負荷（JSONエンコード/デコード）を実行する関数
        function runCpuLoad(loadFactor) {
            // 負荷 1.0 の時に、1フレームあたり 30回 実行するくらいを基準に
            const iterations = Math.floor(30 * loadFactor); 
            
            try {
                for (let i = 0; i < iterations; i++) {
                    // エンコード (stringify) とデコード (parse) の両方を行い、CPU負荷を強化
                    const encoded = JSON.stringify(cpuLoadData);
                    JSON.parse(encoded);
                }
            } catch (e) {
                console.error("CPU load test error:", e);
            }
        }


        // ベンチマーク開始処理
        function startBenchmark() {
            startButton.disabled = true;
            loadSliderGpu.disabled = true; 
            loadSliderCpu.disabled = true; 
            testDurationEl.disabled = true; 

            // 現在の設定を取得
            currentLoadFactorGpu = parseFloat(loadSliderGpu.value);
            currentLoadFactorCpu = parseFloat(loadSliderCpu.value);
            TEST_DURATION = parseInt(testDurationEl.value); 
            
            let OBJECT_COUNT = 0;

            // GPU負荷（オブジェクト数）を計算
            OBJECT_COUNT = Math.floor(BASE_OBJECT_COUNT * currentLoadFactorGpu);
            statusEl.textContent = ` [GPU+CPU] ${OBJECT_COUNT} 個のオブジェクトを初期化中...`;
            
            scoreEl.textContent = '-';
            currentFpsEl.textContent = '-';
            rankEl.textContent = '-';
            maxFpsEl.textContent = '-'; 
            minFpsEl.textContent = '-'; 
            rankEl.className = "text-4xl sm:text-5xl font-extrabold text-gray-500"; 

            // UIを更新するため、重い処理を次のフレームに回す
            setTimeout(() => {
                // [改善点①] 既存のオブジェクトのジオメトリをdisposeしてメモリリークを防ぐ
                // マテリアルは共有しているため、ここではdisposeしない
                group.children.forEach(obj => {
                    if (obj.geometry) obj.geometry.dispose();
                    // マテリアルは共有しているため、disposeしない
                });
                group.clear(); 

                // 大量のオブジェクトを生成
                for (let i = 0; i < OBJECT_COUNT; i++) {
                    // [改善案1] 共有マテリアルからランダムに選択
                    const material = sharedMaterials[Math.floor(Math.random() * NUM_SHARED_MATERIALS)];
                    
                    // Geometryは共有
                    const cube = new THREE.Mesh(geometry, material);

                    // ランダムな位置と回転を設定
                    cube.position.set(
                        (Math.random() - 0.5) * 150,
                        (Math.random() - 0.5) * 150,
                        (Math.random() - 0.5) * 150
                    );
                    cube.rotation.set(
                        Math.random() * Math.PI * 2,
                        Math.random() * Math.PI * 2,
                        Math.random() * Math.PI * 2
                    );
                    
                    // [改善案2] 個別回転用のランダムな速度プロパティを追加
                    // グループ回転とは別に、オブジェクト自体にも独自の回転負荷を与える
                    cube.rotationSpeedX = (Math.random() - 0.5) * 0.5; 
                    cube.rotationSpeedY = (Math.random() - 0.5) * 0.5;
                    cube.rotationSpeedZ = (Math.random() - 0.5) * 0.5; 

                    group.add(cube);
                }

                // 統計情報をリセットして開始
                totalFrames = 0;
                averageFPS = 0;
                currentFPS = 0;
                minFPS = Infinity; 
                maxFPS = 0;        
                fpsHistory.length = 0; 
                
                startTime = performance.now();
                lastTime = startTime;
                isRunning = true;

                // ステータス表示に現在の秒数を含める
                statusEl.textContent = `[GPU+CPU] ベンチマーク実行中... (${TEST_DURATION}秒)`;
                
            }, 10); // 10ms待機
        }

        // ランクを決定するヘルパー関数
        function getRank(fps) {
            if (fps >= 60) return { rank: 'S', color: 'text-yellow-400' };
            if (fps >= 50) return { rank: 'A', color: 'text-red-400' };
            if (fps >= 40) return { rank: 'B', color: 'text-blue-400' };
            if (fps >= 30) return { rank: 'C', color: 'text-green-400' };
            if (fps >= 20) return { rank: 'D', color: 'text-gray-400' };
            return { rank: 'E', color: 'text-gray-600' };
        }

        // ベンチマーク停止処理
        function stopBenchmark() {
            isRunning = false;
            startButton.disabled = false;
            loadSliderGpu.disabled = false; 
            loadSliderCpu.disabled = false; 
            testDurationEl.disabled = false; 
            
            // 最終スコアを計算して表示
            const finalScore = averageFPS.toFixed(1);
            const { rank, color } = getRank(averageFPS);

            statusEl.textContent = `[GPU+CPU] テスト完了！ 最終スコア: ${finalScore} FPS`;
            scoreEl.textContent = finalScore;
            currentFpsEl.textContent = '0.0';
            rankEl.textContent = rank;
            rankEl.className = `text-4xl sm:text-5xl font-extrabold ${color}`; // ランクに応じて色を変更

            // [改善点⑤] Min/Max FPSの表示
            maxFpsEl.textContent = maxFPS.toFixed(1);
            minFpsEl.textContent = (minFPS === Infinity ? 0 : minFPS).toFixed(1);
        }

        // ウィンドウリサイズ処理
        function onWindowResize() {
            camera.aspect = canvasContainer.clientWidth / canvasContainer.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        }

        // アニメーションループ
        function animate() {
            requestAnimationFrame(animate);

            const now = performance.now();
            const delta = (now - lastTime) / 1000; // 秒単位の経過時間
            lastTime = now;

            if (isRunning) {

                // --- GPU負荷の更新 ---
                // [改善案2] 個別オブジェクトの回転処理
                group.children.forEach(obj => {
                    // カスタムプロパティ（rotationSpeedXなど）があるオブジェクトのみを回転
                    if (obj.rotationSpeedX) {
                        obj.rotation.x += obj.rotationSpeedX * delta;
                        obj.rotation.y += obj.rotationSpeedY * delta;
                        obj.rotation.z += obj.rotationSpeedZ * delta;
                    }
                });

                // オブジェクトのグループ全体を回転させる (大きな動き)
                group.rotation.y += 0.1 * delta;
                group.rotation.x += 0.05 * delta;
                
                // --- CPU負荷の更新 ---
                runCpuLoad(currentLoadFactorCpu); // CPU負荷を常に実行

                // --- 統計情報の更新 ---
                totalFrames++;
                const elapsedTime = (now - startTime) / 1000; // 合計経過時間（秒）
                
                // [改善点②] 移動平均を計算してブレを抑えたCurrent FPSを取得
                const smoothedFPS = calcSmoothedFPS(delta); 
                currentFPS = smoothedFPS; 
                averageFPS = totalFrames / elapsedTime; // 平均FPS

                // [改善点⑤] Min/Max FPSの更新 (テスト開始後1秒経過してから計測開始)
                if (elapsedTime > 1.0) {
                    if (smoothedFPS < minFPS) {
                        minFPS = smoothedFPS;
                    }
                    if (smoothedFPS > maxFPS) {
                        maxFPS = smoothedFPS;
                    }
                }

                // --- UIの更新 ---
                currentFpsEl.textContent = currentFPS.toFixed(1);
                scoreEl.textContent = averageFPS.toFixed(1);

                // --- テスト終了判定 ---
                if (elapsedTime >= TEST_DURATION) {
                    stopBenchmark();
                }
            }
            
            // レンダリング
            renderer.render(scene, camera);
        }

        // 初期化実行
        window.onload = init; // 確実にウィンドウロード後に実行
    </script>
</body>
</html>
